version: '3'

vars:
  # Config file
  CONFIG: st.config
  DEFAULT_CONFIG: contrib/default.config
  # Build Targets
  ISO: out/stboot.iso
  IMAGE: out/stboot.img
  # Build Artifacts
  DATA_PART: out/artifacts/data_partition.ext4
  BOOT_PART: out/artifacts/boot_partition.vfat
  KERNEL_FILE: out/artifacts/linuxboot.vmlinuz
  INITRAMFS_FILE: out/artifacts/initramfs-linuxboot.cpio.gz
  INITRAMFS_INCLUDE: contrib/initramfs-includes
  SECURITY_CONFIG: out/artifacts/security_configuration.json
  SIGNKEYS_DIR:
    sh: "dirname {{.ST_SIGNING_ROOT}} 2>/dev/null || echo invalid"
  # task helper script
  CONFIG_HELPER: "CONFIG={{.CONFIG}} ./.task_config.sh"
  GOBIN: cache/go/bin

dotenv:
  - "{{.CONFIG}}"

includes:
  go: ./tasks/go.yml
  deps: ./tasks/deps.yml
  demo: ./tasks/demo.yml

output: 'prefixed'

tasks:

  default:
    cmds:
      - task: images

  images:
    desc: Build stboot images
    deps:
      - disk
      - iso
    run: once

  config:
    desc: Generate default configuration
    sources:
      - "{{.DEFAULT_CONFIG}}"
    generates:
      - "{{.CONFIG}}"
    cmds:
      - "{{.CONFIG_SCRIPT}} -o {{.CONFIG}}"
    vars:
      CONFIG_SCRIPT: ./scripts/config.sh

  toolchain:
    desc: Build toolchain
    deps:
      - go:update

  iso:
    desc: Build stboot iso image
    deps:
      - boot-part
    sources:
      - "{{.BOOT_PART}}"
    generates:
      - "{{.ISO}}"
    cmds:
      - "rm -rf cache/iso"
      - "mkdir -p cache/iso"
      - "cp {{.BOOT_PART}} cache/iso/boot_partition.vfat"
      - "xorriso -as mkisofs -R -f -e boot_partition.vfat -no-emul-boot -o {{.ISO}} cache/iso"
    preconditions:
      - sh: '[ "{{.ST_BOOT_MODE}}" == "network" ]'
        msg: "ISO image does only support network boot mode"
    run: once

  disk:
    desc: Build stboot disk image
    deps:
      - boot-part
      - data-part
    sources:
      - "{{.BOOT_PART}}"
      - "{{.DATA_PART}}"
    generates:
      - "{{.IMAGE}}"
    method: timestamp
    cmds:
      - "{{.IMAGE_SCRIPT}} --boot {{.BOOT_PART}} --data {{.DATA_PART}} --output {{.IMAGE}}"
    status:
      - "{{.CONFIG_HELPER}} image {{.IMAGE_SCRIPT}}"
      - "test -f {{.IMAGE}}"
    preconditions:
      - &check-config
        sh: "[ -f {{.CONFIG}} ]"
        msg: "[ERROR] File \"{{.CONFIG}}\" missing\nPlease provide a configuration file or run \"task config\""
    run: once
    vars:
      IMAGE_SCRIPT: ./scripts/image.sh

  boot-part:
    deps:
      - kernel
    sources:
      - "{{.KERNEL_FILE}}"
    generates:
      - "{{.BOOT_PART}}"
    method: timestamp
    cmds:
      - "{{.BOOT_PART_SCRIPT}} --kernel {{.KERNEL_FILE}} -o {{.BOOT_PART}}"
    status:
      - "{{.CONFIG_HELPER}} boot-part {{.BOOT_PART_SCRIPT}}"
      - "test -f {{.BOOT_PART}}"
    preconditions:
      - *check-config
    run: once
    vars:
      BOOT_PART_SCRIPT: ./scripts/boot_partition.sh

  data-part:
    sources:
      - "{{.ST_LOCAL_OSPKG_DIR}}/**"
    generates:
      - "{{.DATA_PART}}"
    method: timestamp
    cmds:
      - "{{.DATA_PART_SCRIPT}} -o {{.DATA_PART}}"
    status:
      - "{{.CONFIG_HELPER}} data-part {{.DATA_PART_SCRIPT}}"
    preconditions:
      - *check-config
      - sh: '[ -z "$ST_BOOT_MODE" ] || [ "$ST_BOOT_MODE" != "local" ] || (find {{.ST_LOCAL_OSPKG_DIR}} -name \*.zip | read)'
        msg: "[ERROR] Path \"{{.ST_LOCAL_OSPKG_DIR}}\" does not contain any OS package, which is required in Local Boot Mode.\n
        Please provide an OS Package or run \"task demo:ospkg\" to generate an example OS Package"
      - sh: '[ -z "$ST_BOOT_MODE" ] || [ "$ST_BOOT_MODE" != "local" ] || [ -f "{{.ST_LOCAL_OSPKG_DIR}}/boot_order" ]'
        msg: "[ERROR] Local Boot requires {{.ST_LOCAL_OSPKG_DIR}}/boot_order file"
    run: once
    vars:
      DATA_PART_SCRIPT: ./scripts/data_partition.sh

  security-config:
    generates:
      - "{{.SECURITY_CONFIG}}"
    cmds:
      - "{{.SECURITY_CONFIG_SCRIPT}} -o {{.SECURITY_CONFIG}}"
    status:
      - "{{.CONFIG_HELPER}} security-config {{.SECURITY_CONFIG_SCRIPT}}"
      - "test -f {{.SECURITY_CONFIG}}"
    preconditions:
      - *check-config
    run: once
    vars:
      SECURITY_CONFIG_SCRIPT: ./scripts/security_config.sh

  kernel:
    desc: Build LinuxBoot kernel
    deps:
      - initramfs
    sources:
      - "{{.INITRAMFS_FILE}}"
    generates:
      - "{{.KERNEL_FILE}}"
    method: timestamp
    cmds:
      - "make -f {{.LINUX_MAKE}} KERNEL={{.KERNEL_FILE}} CONFIG={{.CONFIG}}"
    status:
      - "{{.CONFIG_HELPER}} kernel {{.LINUX_MAKE}}"
    preconditions:
      - *check-config
    run: once
    vars:
      LINUX_MAKE: modules/linux.mk

  # serially fetch u-root dependencies
  u-root-packages:
    cmds:
      - task: go:checkout
        vars:
          REPO: github.com/u-root/u-root
          BRANCH: "{{.ST_UROOT_VERSION}}"
      - task: go:checkout
        vars:
          REPO: github.com/system-transparency/stboot
          BRANCH: "{{.ST_STBOOT_VERSION}}"
      - task: go:get
        vars:
          REPO: github.com/u-root/cpu

  initramfs:
    deps:
      - go:u-root
      - go:cpu
      - security-config
      # TODO: generate ssh keys only for debug build
      - cpu-sshkeys
      - u-root-packages
    env:
      GO111MODULE: off
    sources:
      - "{{.ST_HOST_CONFIG}}"
      - "{{.SECURITY_CONFIG}}"
      - "{{.ST_SIGNING_ROOT}}"
      - "{{.UROOT_REPO}}/**"
      - "{{.STBOOT_REPO}}/**"
    generates:
      - "{{.INITRAMFS_FILE}}"
    method: timestamp
    cmds:
      - "{{.INITRAMFS_SCRIPT}} -i {{.INITRAMFS_INCLUDE}} -s {{.SECURITY_CONFIG}} -h {{.ST_HOST_CONFIG}} -o {{.INITRAMFS_FILE}}"
    status:
      - "{{.CONFIG_HELPER}} initramfs {{.INITRAMFS_SCRIPT}}"
      - "test -f {{.INITRAMFS_FILE}}"
    preconditions:
      - *check-config
      - sh: "[ -n \"{{.ST_HOST_CONFIG}}\" ]"
        msg: "[ERROR] Configuration ST_HOST_CONFIG not defined in {{.CONFIG}}"
      - sh: "[ -n \"{{.ST_HOST_CONFIG}}\" ] && [ -f \"{{.ST_HOST_CONFIG}}\" ]"
        msg: "[ERROR] Host configuration file \"{{.ST_HOST_CONFIG}}\" missing"
      - sh: "[ -e \"{{.ST_SIGNING_ROOT}}\" ]"
        msg: "[ERROR] root certificate ({{.ST_SIGNING_ROOT}}) missing\nPlease provide a certificate or run \"task demo:keygen\" to generate example keys"
    run: once
    vars:
      INITRAMFS_SCRIPT: ./scripts/initramfs.sh
      UROOT_REPO: "cache/go/src/github.com/u-root/u-root"
      STBOOT_REPO: "cache/go/src/github.com/system-transparency/stboot"

  cpu-sshkeys:
    generates:
      - "{{.CPUKEYS_DIR}}/*"
    cmds:
      - "{{.KEYGEN_CPU_SCRIPT}} -o {{.CPUKEYS_DIR}}"
    status:
      - "{{.CONFIG_HELPER}} keygen-cpu {{.KEYGEN_CPU_SCRIPT}}"
    run: once
    vars:
      KEYGEN_CPU_SCRIPT: ./scripts/cpu_keys.sh
      CPUKEYS_DIR: out/keys/cpu_keys/

######## QEMU run ########

  run-disk:
    desc: Run stboot disk image in QEMU
    deps:
      - task: deps:check-cmd
        vars: {CMD: "qemu-system-x86_64"}
      - disk
    cmds:
      - "{{.QEMU_RUN_SCRIPT}} -i {{.IMAGE}}"
    interactive: true
    vars:
      QEMU_RUN_SCRIPT: ./scripts/qemu_run.sh

  run-iso:
    desc: Run stboot iso image in QEMU
    deps:
      - task: deps:check-cmd
        vars: {CMD: "qemu-system-x86_64"}
      - iso
    cmds:
      - "{{.QEMU_RUN_SCRIPT}} -i {{.ISO}}"
    interactive: true
    vars:
      QEMU_RUN_SCRIPT: ./scripts/qemu_run.sh

######## cleanup ########

  clean:
    desc: Remove all build artifacts
    cmds:
      - "rm -rf out"

  clean-toolchain:
    desc: Remove all go tools
    deps:
      - go:clean

  clean-all:
    desc: Remove all build artifacts, cache and config file
    deps:
      - clean
      - go:clean
    cmds:
      - "rm -rf cache"
      - "rm -rf .task"
      - "rm -f {{.CONFIG}}"
